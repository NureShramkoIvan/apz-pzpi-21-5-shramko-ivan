1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Для реалізації системи була використана мікросервісна архітектура, система складається з двох сервісів, відповідальності яких розмежовані. Основний сервіс відповідає за створення, редагування, отримання та видалення користувачів системи, тренувальних груп, програм, сесій також авторизацію та аутентифікацію, створення та управління резервними копіями бази даних. Другий сервіс опрацьовує результати тренувальних сесій, приймає дані отримані з пристроїв, зберігає результати, обчислює результати тренувань. Дана архітектура була вибрана для оптимізації роботи програми, розподілення навантаження, таке розмежування відповідальності обумовлюється отриманням великої кількості інформації з пристроїв, тому логіку опрацювання цих даних було винесено окремо, задля запобіганню перевантаження системи. Також система використовує асинхронну модель, основану на обробці подій та черг повідомлень, наприклад отримання нової інформації з пристроїв. Також був використаний архітектурний паттерн CQRS(Command and Query Responsibility Segregation). Вибір даного паттерну обумовлений такими його перевагами як розділення операцій читання та створення, оновлення, видалення, що позитивно впливає на ефективність роботи програми.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Для реалізації системи вибрано технологію .NET Core 8.0 та супутні технології ASP.NET CORE 8.0 та ADO.NET. Для розгортання системи використано хмарну платформу Azure, а саме наступні сервіси: Azure App Service для розгортання мікросервісів, Azure SQL Database для розгортання баз даних, Azure IoT Hub, Event Hub, Azure Service Bus, Azure Function для обробки даних з пристроїв та Azure Blob Storage для зберігання файлів резервних копій. Основний сервіс використовує формат передачі даних JSON та протокол HTTPS, а комунікація між основним сервісом та сервісом обробки результатів здійснюється за допомогою gRPC, діаграма розгортання зображена на рисунку 2.2. 
Вибір технологій обумовлений різноманітністю представлених конструкцій для розробки, гнучкість налаштування готових компонентів, актуальністю даної версії та довгострокової підтримки даних технологій.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

3.1 Архітектура системи
Для реалізації системи була використана мікросервісна архітектура, система складається з двох сервісів, відповідальності яких розмежовані. Основний сервіс відповідає за створення, редагування, отримання та видалення користувачів системи, тренувальних груп, програм, сесій також авторизацію та аутентифікацію, створення та управління резервними копіями бази даних. Другий сервіс опрацьовує результати тренувальних сесій, приймає дані отримані з пристроїв, зберігає результати, обчислює результати тренувань. Дана архітектура була вибрана для оптимізації роботи програми, розподілення навантаження, таке розмежування відповідальності обумовлюється отриманням великої кількості інформації з пристроїв, тому логіку опрацювання цих даних було винесено окремо, задля запобіганню перевантаження системи. Також система використовує асинхронну модель, основану на обробці подій та черг повідомлень, наприклад отримання нової інформації з пристроїв. Також був використаний архітектурний паттерн CQRS(Command and Query Responsibility Segregation). Вибір даного паттерну обумовлений такими його перевагами як розділення операцій читання та створення, оновлення, видалення, що позитивно впливає на ефективність роботи програми.
3.2 Фізична модель бази даних
Для зберігання даних була використана база даних SQL Server та технологія ADO.NET для комунікації з базою даних.
Фізична модель бази даних відповідає моделі предметної області, також для кожного мікросервісу використовується окрема база даних. Схеми баз даних наведені на рисунках 2.3-2.4.
Таблиці були розширені додатковими атрибутами, були додані атрибути унікального ідентифікатора, зв’язки між пов’язаними таблицями реалізуються за допомогою зовнішніх ключів, що забезпечує цілісність даних, бази даних нормалізовані до 3 Нормальної Форми. Для отримання даних використовується мова SQL та API ORM ADO.NET.
3.3 Безпека, захист даних, авторизація та аутентифікація
Система використовує захищену взаємодію з сервером з використанням протоколу HTTPS. У прикладі коду наведеному нижче на строці 7 встановлюється перенаправлення запитів по протоколу HTTP на HTTPS, на строці 5 встановлюється використання протоколу HTTP Strict Transport Security Protocol.
Дані засоби сприяють безпеці застосунку, перенаправлення по протоколу HTTPS перенаправляє запити по захищеному протоколу, а використання HSTS убезпечує з’єднання під час першого запиту по протоколу HTTP задля попередження можливих атак.
Також для надійного захисту користувацьких даних використовується хешування. У прикладі коду наведеному нижче демонструється хешування паролів користувачів.
Для хешування використовується алгоритм PBKDF2, що відповідає стандарту Rfc2898.
В застосунку передбачені механізми авторизації та аутентифікації на основі використання JWT-токенів.
Токени генеруються на основі алгоритму SHA256, використовуючи приватний ключ на стороні серверного застосунку такий підхід захищає від підробки даний токен. Для перевірки токенів використовуються вбудовані засоби ASP.NET для захисту Web API застосунку.
3.4 Адміністрування системи, створення резервних копій, управління користувачами
Одна з функцій передбачених в системі, що стосується її адміністрування це створення резервних копій баз даних, для реалізації цього функціоналу застосовувалися SQL SERVER та Azure Blob Storage. У фрагменті коду наведеному нижче використовуючи засоби мови SQL, виконуються команди для створення резервних копій, які зберігаються у хмарному сховищі.
Для забезпечення безпеки під час створення резервних копій та несанкціонованого доступу до хмарного сховища використовується спеціальний токен доступу, на порталі Azure. На рисунку 3.1 зображено зберігання створених резервних копій у хмарному сховищі.
Наведений нижче блок коду виконує скачування резервних копій, використовуючи API  Azure Blob Storage.
Також система підтримує засоби управління користувачами, що включає створення, редагування, перегляд та видалення даних про користувачів, для реалізації даної функціональності використано бібліотеку ASP.NET Core Identity. Прикладу коду програмного застосунку, що відповідаєють за управління користувачами наведені у додатку Б.
3.5 Робота з датами і часом
У застосунку передбачена обробка даних та часу з використанням різних часових зон для користувачів, обробка вхідних значень дати і часу використовуючи зміщення часу для часових зон, використання літнього та зимового часу, конвертація та зберігання дати і часу у форматі UTC,  програма опрацьовує значення дати і часу у форматі ISO.
У наведеному нижче фрагменті коду для приймання даних з тіла HTTP запиту використовується структура DateTimeOffset, яка зберігає в собі різницю в часі від UTC, це значення конвертується до UTC.
В застосунку закладена підтримка декількох часових зон, а саме Central Standard Time, Tokyo Standard Time, FLE Standard Time. При створенні користувача вказується його часова зона, згодом при обробці даних з клієнтських застосунків або передачі значень у відповідь, значення дати і часу переводяться до відповідної часової зони. У наведеному нижче прикладі коду продемонстровано частину моделі представлення користувача, яка зберігає і в собі його часову зону.
У наступному фрагменті коду продемонстрировано конвертацію значення дати і часу відповідно до часовою зони користувача.
В даному фрагменті коду продемонстровано використання структури даних TimeZoneInfo, що знаходить часову зону за її ідентифікатором та конвертує передане значення, використовуючи різницю у часі та інформацію про використання літнього часу та зимового часу.
3.6 Локалізація та інтернаціоналізація
Програмний застосунок підтримує локалізацію та інтернаціоналізацію текстових значень. Для визначення локалю використовується HTTP заголовок Accept-Language, локалі що  підтримуються: американська англійська(en-US) та українська(uk-UA). Для зберігання відповідних текстових значень для кожного локалю використовуються файли ресурсів(рис 3.2-3.3).
У наведеному нижче фрагментах коду демонструється логіка визначення локалю та переведення текстового значення до відповідного.
3.7 Використання ефективних математичних методів обробки даних
В застосунку реалізовані математичні методи обробки даних результатів тренувань відповідно до бізнес-логіки. Реалізовано наступні математичні розрахунки: розрахунок часу проходження тренування, процент успішно та неуспішо пройдених етапів програми, розрахунок успішності результату проходження тренувальної сесії користувачем відносно результатів інших користувачів у групі.
Час проходження програми розраховується за формулою:
T = nk =1(Tk - T0-k-1m =1Tm) 
де T0 - час початку спроби користувача
     Tk - час проходження конкретного етапу програми
     Tm - час витрачений на проходження точки
Процент успішно пройдених етапів програми розраховується за формулою:
Pусп. = Nусп. / N 
де Nусп. - кількість етапів програми проходження яких зафіксовано
     N - загальна кількість етапів програми
Процент успішно пройдених етапів програми розраховується за формулою:
Pне усп. = (N - Nусп.) / N 
де Nусп. - кількість етапів програми проходження яких зафіксовано
     N - загальна кількість етапів програми
Коефіцієнт успішності результату проходження тренувальної сесії користувачем розраховується за формулою:
K = Tm / T  
де Tm. - медіанне значення часу проходження програми серед учасників групи
     T - час проходження програми користувачем
Приклади фрагментів коду математичних розрахунків наведені в додатку В.
3.8 Використання архітектурних шаблонів
Окрім проектування на рівні загальної архітектури, в застосунку використовувалися архітектурні шаблони та шаблони проектування на рівні окремих частин системи та класів. Були використані такі загальноприйняті шаблони як Model-View-Controller, Inversion of Control(Dependency Injection), CQRS, а також шаблони з групи GoF. 
Шаблон MVC використовувався на рівні представлення, де модель була представлена класами предметної області які містили в собі бізнес-логіку та зверталися до бази даних, контроллер зв’язував модель і представлення та відправляв результат у вигляді JSON.
Для передачі залежностей в класи які їх потребують, використовувався шаблон Inversion of Control(Dependency Injection), який полягає в передачі залежностей зовні, використовуючи конструктор класу, попередню зареєструвавши їх в класі контейнері, таким чином зменшується зв’язаність коду, підтримується його модульність та уникається використання неявних залежностей.  В фрагменті коду наведеному нижче демонструється реєстрація залежностей та їх використання.
Шаблон Command and Query Responsibility Segregation використовувався для розмежування операцій читання та редагування, видалення, оновлення при зверненні до бази. Таким чином за рахунок розділення операцій підтримується незалежність частин програми та забезпечується масштабованість.
Також був використаний шаблон Builder з групи GoF. Наступний фрагмент коду демонструє використання цього шаблону при конструюванні об’єкту конфігурації програми.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Основною задачею програмної системи в тому числі і серверної частини застосунку є забезпечення автоматизації процесу навчання та проведення змагань з керування дронами. Основними акторами системи є користувач, адміністратор та інструктор, діаграми прецедентів для кожного типу користувачів зображені на рисунках 1.1-1.3.
Функції адміністратора поділені по категоріям: управління користувачами та адміністрування системи, також адміністратор має функції створення, видалення та управління профілями організацій які використовують дану систему, в тому числі керування набором доступних приладів для кожної організації.
Інструктор в системі має такі основні функції: створення та управління тренувальними групами, додавання нових користувачів до групи, видалення користувачів із групи, створення, редагування та управління тренувальними програмами з використанням пристроїв доступних організації, призначенні певній тренувальній групі сесії з визначеною програмою, інструктор також починає та закінчує тренувальну сесію, відслідковує прогрес проходження тренувальної програми учасниками тренувальної сесії.
Функції доступні учаснику включають в себе перегляд тренувальних сесій призначених йому, проходження тренувальних сесій, перегляд результатів вибраної тренувальної сесії.
Основна задача програмної системи має на меті проведення тренувальних сесій. Проведення тренувальної сесії з подальшим переглядом результатів є основним сценарієм використання системи. Для цього адміністратор системи спершу має створити нову організацію та додати до її профіля потрібну кількість пристроїв вказавши їх тип або якщо організація вже створена та її профіль налаштований вибрати існуючу , далі адміністратор додає до організації нового інструктора в разі якщо організація не має інструкторів. Наступним кроком є налаштування процесу тренування для цього інструктор створює тренувальну групу або використовує існуючу, додає до тренувальної групи користувачів, які будуть її учасника, далі інструктор створює програму тренувальної сесії використовуючи доступні пристрої, останнім кроком перед проведенням тренування є створення тренувально сесії, інструктор вибирає групу та програму, встановлює дату та час проведення. Під час проведення тренування інструктор по черзі запускає проходження програми для кожного учасника в групі, фіксуючи його результати після закінчення тренування учасникам і інструктору доступні результати тренувальної сесії, основний сценарій використання програмної системи зображений використовуючи діаграму активностей, діаграму розміщено у додатку А.             

5 ПОБУДОВА ER-ДІАГРАМИ

Перед початком імплементації програмної системи була розроблена модель предметної області. Основні сутностостями в даній системі є організація, інструктор учасник, тренувальна група, тренувальна програма, тренувальна сесія, пристрій, етап тренувальної програми. ER-діаграма зображена на рисунку 2.1.
Між сутностями предметної області визначені такі зв’язки: інструктор належить до організації, одна організація може мати декілька інструкторів, але один інструктор може належати лише до однієї організації, одна організація має багато пристроїв, тренувальна група створюються інструктором, одна тренувальна група може мати одного інструктора, один інструктор може мати декілька тренувальних груп. Тренувальна група складається з учасників, один учасник може входити до декількох тренувальних груп, одна тренувальна група може мати багато учасників. Тренувальна сесія призначена одній тренувальній групі, тренувальна сесія проходить за однією тренувальною програмою. Тренувальна програма складається з багатьох етапів, один пристрій використовується тільки на одному етапі.

6 СПЕЦИФІКАЦІЯ REST

Під час проектування системи закладено взаємодію клієнтських та серверної частини через протоколи HTTP/HTTPS, для цього було сформовано REST специфікацію, описану у таблиці 3.1.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Замість діаграми компонентів було створено діаграму активностей.

ВИСНОВКИ

В результаті розробки серверної частини програмної системи «Програмна система для автоматизації проведення тренувань та змагань з керування дронами» описано прийняті інженерні рішення, загальну архітектуру системи, описано будову її серверних компонентів та структуру бази даних, також створено специфікацію REST, додано функції адміністрування системи, створення резервних копій баз даних, забезпечення надійного зберігання даних користувачів, використовуються безпечні протоколи взаємодії, забезпечена локалізація та інтернаціоналізація, робота з датами та часом, механізми авторизації та аутентифікації, реалізовані математичні методи обробки даних. Звіт включає в себе наступні діаграми: UML діаграму розгортання, UML діаграму прецедентів, ER-модель даних, UML діаграму діяльності.

ДОДАТОК А

Таблия 3.1 - REST специфікація
Шлях до ресурсу
Метод
Опис
/api/backups
POST
Створення нової резервної копії.
/api/backups
GET
Отримання списку усіх резервних копій.
/api/backups/{file_name}
GET
Отримання конкретної резервної копії за ім'ям файлу.
/api/backups/{file_name}
DELETE
Видалення резервної копії за ім'ям файлу.
/api/organizations
POST
Створення нової організації.
/api/organizations/{organization_id}
PUT
Оновлення інформації про організацію.
/api/organizations/{organization_id}
DELETE
Видалення організації за її ідентифікатором.
/api/organizations/{organization_id}/
devices
POST
Додавання нового пристрою до організації.
/api/organizations/{organization_id}/
devices
GET
Отримання списку пристроїв, що належать організації.
/api/organizations/{organization_id}/
devices/{device_id}
PUT
Оновлення інформації про пристрій в організації.
/api/organizations/{organization_id}/
devices/{device_id}
DELETE
Видалення пристрою з організації.
/api/token
POST
Отримання нового токену автентифікації.
/api/training-groups
POST
Створення нової групи навчання.
/api/training-groups/{group_id}
PUT
Оновлення інформації про тренувальну групу.
/api/training-groups/{group_id}
DELETE
Видалення тренувальної групи за її ідентифікатором.
/api/training-groups/{group_id}/
participations
POST
Додавання учасника до групи навчання.
/api/training-groups/{group_id}/
participations/{participant_id}
PUT
Оновлення інформації про учасника групи навчання.
/api/training-groups/{group_id}/
participations/{participant_id}
DELETE
Видалення учасника з групи навчання.
/api/training-programs
POST
Створення нової тренувальної програми.
/api/training-programs/{program_id}
PUT
Оновлення інформації про тренувальну програму.
/api/training-programs/{program_id}
DELETE
Видалення тренувальної програми за її ідентифікатором.
/api/training-sessions
POST
Створення нової сесії навчання.
/api/training-sessions/{session_id}
PUT
Оновлення інформації про сесію навчання.
/api/training-sessions/{session_id}
DELETE
Видалення сесії навчання.
/api/users
POST
Реєстрація нового користувача.
/api/users/{user_id}/training-sessions
GET
Отримання списку навчальних сесій для конкретного користувача.
/api/users/{user_id}/training-sessions/{session_id}/result
GET
Отримання результатів навчальної сесії для конкретного користувача.